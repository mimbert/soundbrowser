#!/usr/bin/env python3

import os, os.path, collections, yaml, schema, signal, sys, pathlib, threading

from PySide2 import QtCore
from PySide2 import QtGui
from PySide2 import QtWidgets
from ui import main_win, prefs_dial

import gi
gi.require_version('Gtk', '3.0')
gi.require_version('Gst', '1.0')
from gi.repository import GObject, Gst, Gtk, GLib

CACHE_SIZE = 256
CONF_FILE = os.path.expanduser("~/.soundbrowser.conf.yaml")

STARTUP_DIR_MODE_SPECIFIED_DIR = 1
STARTUP_DIR_MODE_LAST_DIR = 2
STARTUP_DIR_MODE_CURRENT_DIR = 3
STARTUP_DIR_MODE_HOME_DIR = 4

conf_schema = schema.Schema({
    schema.Optional('startup_dir_mode', default=STARTUP_DIR_MODE_HOME_DIR): int,
    schema.Optional('specified_dir', default=os.path.expanduser('~')): str,
    schema.Optional('last_dir', default=os.path.expanduser('~')): str,
    schema.Optional('show_hidden_files', default=False): bool,
    schema.Optional('show_metadata_pane', default=True): bool,
    schema.Optional('show_parent_folder_in_file_pane', default=True): bool,
    schema.Optional('main_window_geometry', default=None): bytes,
    schema.Optional('main_window_state', default=None): bytes,
    schema.Optional('splitter_state', default=None): bytes,
    schema.Optional('play_looped', default=False): bool,
})

def load_conf(path):
    try:
        with open(path) as fh:
            conf = yaml.safe_load(fh)
    except OSError:
        conf = {}
    return conf_schema.validate(conf)

def save_conf(path, conf):
    conf = conf_schema.validate(conf)
    try:
        with open(path, 'w') as fh:
            yaml.dump(conf, fh)
    except OSError:
        pass

class LRU(collections.OrderedDict):
    'Limit size, evicting the least recently looked-up key when full'

    def __init__(self, maxsize=128, *args, **kwds):
        self.maxsize = maxsize
        super().__init__(*args, **kwds)

    def __getitem__(self, key):
        value = super().__getitem__(key)
        self.move_to_end(key)
        return value

    def __setitem__(self, key, value):
        if key in self:
            self.move_to_end(key)
        super().__setitem__(key, value)
        if len(self) > self.maxsize:
            oldest = next(iter(self))
            del self[oldest]

def gst_bus_message_handler(bus, message, *user_data):
    sound = user_data[0]
    sound.gst_message.emit(message)
    return True

def parse_tag_list(taglist):
    tmp = {}
    containers = {}
    for i in range(taglist.n_tags()):
        tag = taglist.nth_tag_name(i)
        if tag in [ 'title', 'artist', 'album', 'genre', 'musical-key', 'album-artist', 'encoder', 'channel-mode', 'audio-codec', 'container-format', 'comment' ]:
            value = taglist.get_string(tag)
        elif tag in [ 'track-count', 'track-number', 'minimum-bitrate', 'maximum-bitrate', 'bitrate' ]:
            value = taglist.get_uint(tag)
        elif tag == 'duration':
            value = taglist.get_uint64(tag)
        elif tag in [  'beats-per-minute', 'replaygain-track-gain', 'replaygain-album-gain', 'replaygain-track-peak', 'replaygain-album-peak' ]:
            value = taglist.get_double(tag)
        elif tag == 'datetime':
            value = taglist.get_date_time(tag)
            if value[0]:
                value = (True, value[1].to_iso8601_string())
            else:
                value = taglist.get_date(tag)
                if value[0]:
                    value = (True, value[1].to_struct_tm()) # never tested, need to find an example stream
        elif tag == 'has-crc':
            value = taglist.get_boolean(tag)
        elif tag == 'image':
            # not handled (yet?)
            continue
        if value[0]:
            if tag == 'container-format':
                containers[value[1]] = tmp
                tmp = {}
            else:
                tmp[tag] = value[1]
    if len(tmp) > 0:
        containers[None] = tmp
        tmp = {}
    return containers

def get_milliseconds_suffix(secs):
    ms_suffix = ""
    msecs = int (round(secs - int(secs), 3) * 1000)
    if msecs != 0:
        ms_suffix = ".%03i" % msecs
    return ms_suffix

def format_duration(nsecs):
    if nsecs == None:
        return ''
    secs = nsecs / 1e9
    formatted_duration = ""
    if secs < 0:
        secs = -secs
        formatted_duration += "-"
    s = secs
    d = (s - (s % 86400)) // 86400
    s -= d * 86400
    h = (s - (s % 3600)) // 3600
    s -= h * 3600
    m = (s - (s % 60)) // 60
    s -= m * 60
    if secs >= 86400: formatted_duration += "%id" % d
    if secs >= 3600: formatted_duration += "%ih" % h
    if secs >= 60: formatted_duration += "%im" % m
    formatted_duration += "%i%ss" % (s, get_milliseconds_suffix(s))
    return formatted_duration

class Sound(QtCore.QObject):

    gst_message = QtCore.Signal(Gst.Message)

    def __init__(self, path = None, stat_result = None, browser = None):
        super().__init__()
        self.metadata = { None: {}, 'all': {} }
        self.path = path
        self.stat_result = stat_result
        self.browser = browser
        self.player = Gst.ElementFactory.make('playbin')
        self.player.get_bus().add_watch(GLib.PRIORITY_DEFAULT, gst_bus_message_handler, self)
        uri = pathlib.Path(path).as_uri()
        self.player.set_property('uri', uri)
        self.seek_pos_update_timer = QtCore.QTimer()
        self.gst_message.connect(self.receive_gst_message)

    def update_metadata(self, metadata):
        for k in metadata:
            if not k in self.metadata:
                self.metadata[k] = {}
            self.metadata[k].update(metadata[k])
            self.metadata['all'].update(metadata[k])

    def update_metadata_field(self, field, value, force = None):
        f = getattr(self.browser, field)
        l = getattr(self.browser, field + '_label')
        if value or force == True:
            f.setText(str(value))
            f.setEnabled(True)
            l.setEnabled(True)
        if not value or force == False:
            f.setText(str(value))
            f.setEnabled(False)
            l.setEnabled(False)

    def update_metadata_pane(self):
        m = self.metadata['all']
        b = self.browser
        self.update_metadata_field('title', m.get('title', ''))
        self.update_metadata_field('artist', m.get('artist', ''))
        self.update_metadata_field('album', m.get('album', ''))
        self.update_metadata_field('album_artist', m.get('album-artist', ''))
        self.update_metadata_field('track', str(m.get('track-number', '?')) + '/' + str(m.get('track-count', '?')),
                                   True if ('track-number' in m or 'track-count' in m) else False)
        self.update_metadata_field('duration', format_duration(m.get('duration')))
        self.update_metadata_field('genre', m.get('genre', ''))
        self.update_metadata_field('date', m.get('datetime', ''))
        self.update_metadata_field('bpm', f"{m['beats-per-minute']:.2f}" if 'beats-per-minute' in m else '')
        self.update_metadata_field('key', m.get('musical-key', ''))
        self.update_metadata_field('channel_mode', m.get('channel-mode', ''))
        self.update_metadata_field('audio_codec', m.get('audio-codec', ''))
        self.update_metadata_field('encoder', m.get('encoder', ''))
        self.update_metadata_field('bitrate', str(m.get('bitrate', '?')) + ' (min=' + str(m.get('minimum-bitrate', '?')) + '/max=' + str(m.get('maximum-bitrate', '?')) + ')',
                                   True if 'bitrate' in m else False)
        self.update_metadata_field('comment', m.get('comment', ''))

    @QtCore.Slot(Gst.Message)
    def receive_gst_message(self, message):
        #print(f"gst_bus_message_handler message: {message.type}: {message.get_structure().to_string() if message.get_structure() else 'None'}")
        if message.type == Gst.MessageType.STREAM_START:
            self.browser.play.setEnabled(False)
            self.browser.pause.setEnabled(True)
            self.browser.stop.setEnabled(True)
        elif message.type == Gst.MessageType.EOS:
            if self.browser.config['play_looped']:
                self.player.seek_simple(Gst.Format.TIME, Gst.SeekFlags.FLUSH | Gst.SeekFlags.KEY_UNIT, 0)
                self.player.set_state(Gst.State.PLAYING)
            else:
                self.seek_pos_update_timer.stop()
                self.browser.play.setEnabled(True)
                self.browser.pause.setEnabled(False)
                self.browser.stop.setEnabled(False)
        elif message.type == Gst.MessageType.TAG:
            #print(f"{message.type}: {message.get_structure().to_string()}")
            message_struct = message.get_structure()
            taglist = message.parse_tag()
            metadata = parse_tag_list(taglist)
            self.update_metadata(metadata)
            self.update_metadata_pane()
        elif message.type == Gst.MessageType.WARNING:
            print(f"Gstreamer WARNING: {message.type}: {message.get_structure().to_string()}")
        elif message.type == Gst.MessageType.ERROR:
            print(f"Gstreamer ERROR: {message.type}: {message.get_structure().to_string()}")

    @QtCore.Slot()
    def seek_position_updater(self):
        got_duration, duration = self.player.query_duration(Gst.Format.TIME)
        got_position, position = self.player.query_position(Gst.Format.TIME)
        if got_duration:
            if 'duration' not in self.metadata[None] or 'duration' not in self.metadata['all']:
                self.metadata[None]['duration'] = self.metadata['all']['duration'] = duration
                self.update_metadata_pane()
            if got_position:
                signals_blocked = self.browser.seek.blockSignals(True)
                self.browser.seek.setValue(position * 100.0 / duration)
                self.browser.seek.blockSignals(signals_blocked)

    def play(self):
        self.player.set_state(Gst.State.PLAYING)
        self.seek_pos_update_timer.timeout.connect(self.seek_position_updater)
        self.seek_pos_update_timer.start(50)

    def stop(self):
        self.seek_pos_update_timer.stop()
        self.player.set_state(Gst.State.PAUSED)
        self.player.seek_simple(Gst.Format.TIME, Gst.SeekFlags.FLUSH | Gst.SeekFlags.KEY_UNIT, 0)

    def seek(self, position):
        got_duration, duration = self.player.query_duration(Gst.Format.TIME)
        if got_duration:
            seek_pos = position * duration / 100.0
            self.player.seek_simple(Gst.Format.TIME, Gst.SeekFlags.FLUSH | Gst.SeekFlags.KEY_UNIT, seek_pos)

class SoundPlayer():

    def __init__(self, browser):
        self._cache = LRU(maxsize = CACHE_SIZE) # keys: file pathes. Values: Sound
        self._browser = browser
        self._currently_playing = None
        Gst.init(None)

    def get(self, path):
        if path in self._cache:
            if not os.path.isfile(path):
                del self._cache[path]
                return None
            sound = self._cache[path]
            stat_result = os.stat(path)
            if stat_result.st_mtime_ns > sound.stat_result.st_mtime_ns:
                return self._load(path)
            return sound
        else:
            return self._load(path)

    def _load(self, path):
        if not os.path.isfile(path):
            return None
        sound = Sound(path=path, stat_result=os.stat(path), browser=self._browser)
        self._cache[path] = sound
        return sound

    def add_to_play_queue(self, path):
        sound = self.get(path)
        if sound:
            self._currently_playing = sound
            sound.play()
            #sound.update_metadata_pane()

    def remove_from_play_queue(self, path):
        sound = self.get(path)
        if sound:
            sound.stop()

    def currently_playing(self):
        return self._currently_playing

class MyQFileSystemModel(QtWidgets.QFileSystemModel):

    def __init__(self, show_hidden_files, *args, **kwds):
        super().__init__(*args, **kwds)
        self.show_hidden_files = show_hidden_files

    def hasChildren(self, parent):
        if self.flags(parent) & QtCore.Qt.ItemNeverHasChildren:
            return False
        try:
            with os.scandir(self.filePath(parent)) as it:
                for entry in it:
                    if (not entry.name.startswith('.') or self.show_hidden_files) and entry.is_dir():
                        return True
        except PermissionError:
            return False
        return False

class MyQSortFilterProxyModel(QtCore.QSortFilterProxyModel):

    def lessThan(self, left, right):
        if left.column() not in [ 0, 2 ] or right.column() not in [ 0, 2 ]:
            return super().lessThan(left, right)
        info_left = self.sourceModel().fileInfo(left)
        info_right =  self.sourceModel().fileInfo(right)
        if info_left.isDir() and info_right.isFile():
            return True
        elif info_left.isFile() and info_right.isDir():
            return False
        return super().lessThan(left, right)

class PrefsDialog(prefs_dial.Ui_PrefsDialog, QtWidgets.QDialog):

    def __init__(self, *args, **kwds):
        super(PrefsDialog, self).__init__(*args, **kwds)
        self.setupUi(self)
        self.populate()

    def populate(self):
        self.specified_dir_button.clicked.connect(self.specified_dir_button_clicked)

    def specified_dir_button_clicked(self, checked = False):
        path = QtWidgets.QFileDialog.getExistingDirectory(self, "startup directory", self.specified_dir.text())
        if path:
            self.specified_dir.setText(path)


class SoundBrowser(main_win.Ui_MainWindow, QtWidgets.QMainWindow):

    def __init__(self, clipboard):
        super().__init__()
        self.clipboard = clipboard
        self.config = load_conf(CONF_FILE)
        self.player = SoundPlayer(self)
        self.setupUi(self)
        self.populate()

    def clean_close(self):
        self.config['main_window_geometry'] = self.saveGeometry().data()
        self.config['main_window_state'] = self.saveState().data()
        self.config['splitter_state'] = self.splitter.saveState().data()
        if self.config['startup_dir_mode'] == STARTUP_DIR_MODE_LAST_DIR:
            self.config['last_dir'] = self.fs_model.filePath(self.treeView.currentIndex())
        save_conf(CONF_FILE, self.config)

    def closeEvent(self, event):
        self.clean_close()
        event.accept()

    def refresh_config(self):
        self.fs_model.show_hidden_files = self.config['show_hidden_files']
        fs_model_filter = QtCore.QDir.NoDotAndDotDot | QtCore.QDir.AllDirs
        dir_model_filter = QtCore.QDir.Files | QtCore.QDir.AllDirs
        if self.config['show_hidden_files']:
            fs_model_filter |= QtCore.QDir.Hidden
            dir_model_filter |= QtCore.QDir.Hidden
        if self.config['show_parent_folder_in_file_pane']:
            dir_model_filter |= QtCore.QDir.NoDot
        else:
            dir_model_filter |= QtCore.QDir.NoDotAndDotDot
        self.fs_model.setFilter(fs_model_filter)
        self.dir_model.setFilter(dir_model_filter)
        if self.config['show_metadata_pane']:
            self.metadata.show()
        else:
            self.metadata.hide()

    def populate(self):
        self.fs_model = MyQFileSystemModel(self.config['show_hidden_files'], self)
        self.fs_model.setRootPath((QtCore.QDir.rootPath()))
        self.dir_model = QtWidgets.QFileSystemModel(self)
        self.dir_model.setRootPath((QtCore.QDir.rootPath()))
        self.treeView.setModel(self.fs_model)
        self.dir_proxy_model = MyQSortFilterProxyModel(self)
        self.dir_proxy_model.setSourceModel(self.dir_model)
        self.tableView.setModel(self.dir_proxy_model)
        self.tableView.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tableView.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tableView.selectionModel().selectionChanged.connect(self.tableview_selection_changed)
        self.tableView.clicked.connect(self.tableview_clicked)
        self.tableView.setRootIndex(self.dir_proxy_model.mapFromSource(self.dir_model.index('/')))
        self.tableView.verticalHeader().hide()
        self.tableView.horizontalHeader().setSortIndicator(0, QtCore.Qt.AscendingOrder)
        self.tableView.setSortingEnabled(True)
        self.tableView.horizontalHeader().setStretchLastSection(True)
        self.tableView.setHorizontalScrollMode(QtWidgets.QAbstractItemView.ScrollPerPixel)
        self.treeView.setColumnHidden(1, True)
        self.treeView.setColumnHidden(2, True)
        self.treeView.setColumnHidden(3, True)
        self.treeView.selectionModel().selectionChanged.connect(self.treeview_selection_changed)
        self.treeView.setRootIndex(self.fs_model.index('/'))
        if self.config['startup_dir_mode'] == STARTUP_DIR_MODE_SPECIFIED_DIR:
            startup_dir = self.config['specified_dir']
        elif self.config['startup_dir_mode'] == STARTUP_DIR_MODE_LAST_DIR:
            startup_dir = self.config['last_dir']
        elif self.config['startup_dir_mode'] == STARTUP_DIR_MODE_CURRENT_DIR:
            startup_dir = os.getcwd()
        elif self.config['startup_dir_mode'] == STARTUP_DIR_MODE_HOME_DIR:
            startup_dir = os.path.expanduser('~')
        self.treeView.setCurrentIndex(self.fs_model.index(startup_dir))
        self.treeView.expand(self.fs_model.index(startup_dir))
        self.treeView.header().setSortIndicator(0,QtCore.Qt.AscendingOrder)
        self.treeView.setSortingEnabled(True)
        self.treeView.setHorizontalScrollMode(QtWidgets.QAbstractItemView.ScrollPerPixel)
        self.dir_model.directoryLoaded.connect(self.dir_model_directory_loaded)
        self.prefsButton.clicked.connect(self.prefs_button_clicked)
        self.seek.valueChanged.connect(self.slider_value_changed)
        self.loop.setChecked(self.config['play_looped'])
        self.show_hidden_files.setChecked(self.config['show_hidden_files'])
        self.show_metadata_pane.setChecked(self.config['show_metadata_pane'])
        self.loop.clicked.connect(self.loop_clicked)
        self.show_hidden_files.clicked.connect(self.show_hidden_files_clicked)
        self.show_metadata_pane.clicked.connect(self.show_metadata_pane_clicked)
        self.copy_path.clicked.connect(self.copy_path_clicked)
        self.refresh_config()
        if self.config['main_window_geometry']:
            self.restoreGeometry(QtCore.QByteArray(self.config['main_window_geometry']))
        if self.config['main_window_state']:
            self.restoreState(QtCore.QByteArray(self.config['main_window_state']))
        if self.config['splitter_state']:
            self.splitter.restoreState(QtCore.QByteArray(self.config['splitter_state']))

    def dir_model_directory_loaded(self, path):
        self.tableView.resizeColumnToContents(0)

    def treeview_selection_changed(self, selected, deselected):
        path = self.fs_model.filePath(self.treeView.currentIndex())
        self.locationBar.setText(path)
        self.tableView.setRootIndex(self.dir_proxy_model.mapFromSource(self.dir_model.index(path)))
        self.treeView.setCurrentIndex(self.fs_model.index(path))
        self.treeView.expand(self.fs_model.index(path))

    def tableview_selection_changed(self, selected, deselected):
        for r in deselected:
            for pmi in r.indexes():
                path = self.dir_model.filePath(self.dir_proxy_model.mapToSource(pmi))
                self.player.remove_from_play_queue(path)
        path = self.dir_model.filePath(self.dir_proxy_model.mapToSource(self.tableView.currentIndex()))
        self.player.add_to_play_queue(path)
        self.locationBar.setText(path)
        sound = self.player.get(path)
        if sound: sound.update_metadata_pane()

    def tableview_clicked(self, index):
        fi = self.dir_model.fileInfo(self.dir_proxy_model.mapToSource(index))
        if fi.isDir():
            path = self.dir_model.filePath(self.dir_proxy_model.mapToSource(index))
            self.locationBar.setText(path)
            self.tableView.setRootIndex(self.dir_proxy_model.mapFromSource(self.dir_model.index(path)))
            self.treeView.setCurrentIndex(self.fs_model.index(path))
            self.treeView.expand(self.fs_model.index(path))
        else:
            for r in self.tableView.selectionModel().selection():
                for pmi in r.indexes():
                    path = self.dir_model.filePath(self.dir_proxy_model.mapToSource(pmi))
                    self.player.remove_from_play_queue(path)
            path = self.dir_model.filePath(self.dir_proxy_model.mapToSource(index))
            self.player.add_to_play_queue(path)
            self.locationBar.setText(path)
            sound = self.player.get(path)
            if sound: sound.update_metadata_pane()

    def loop_clicked(self, checked = False):
        self.config['play_looped'] = checked

    def show_hidden_files_clicked(self, checked = False):
        self.config['show_hidden_files'] = checked
        self.refresh_config()

    def show_metadata_pane_clicked(self, checked = False):
        self.config['show_metadata_pane'] = checked
        self.refresh_config()

    def prefs_button_clicked(self, checked = False):
        prefs = PrefsDialog(self)
        #prefs.show_hidden_files.setChecked(self.config['show_hidden_files'])
        prefs.specified_dir.setText(self.config['specified_dir'])
        if self.config['startup_dir_mode'] == STARTUP_DIR_MODE_SPECIFIED_DIR:
            prefs.startup_dir_mode_specified_dir.setChecked(True)
        elif self.config['startup_dir_mode'] == STARTUP_DIR_MODE_LAST_DIR:
            prefs.startup_dir_mode_last_dir.setChecked(True)
        elif self.config['startup_dir_mode'] == STARTUP_DIR_MODE_CURRENT_DIR:
            prefs.startup_dir_mode_current_dir.setChecked(True)
        elif self.config['startup_dir_mode'] == STARTUP_DIR_MODE_HOME_DIR:
            prefs.startup_dir_mode_home_dir.setChecked(True)
        if prefs.exec_():
            #self.config['show_hidden_files'] = prefs.show_hidden_files.isChecked()
            if prefs.startup_dir_mode_specified_dir.isChecked():
                self.config['startup_dir_mode'] = STARTUP_DIR_MODE_SPECIFIED_DIR
            elif prefs.startup_dir_mode_last_dir.isChecked():
                self.config['startup_dir_mode'] = STARTUP_DIR_MODE_LAST_DIR
            elif prefs.startup_dir_mode_current_dir.isChecked():
                self.config['startup_dir_mode'] = STARTUP_DIR_MODE_CURRENT_DIR
            elif prefs.startup_dir_mode_home_dir.isChecked():
                self.config['startup_dir_mode'] = STARTUP_DIR_MODE_HOME_DIR
            self.config['specified_dir'] = prefs.specified_dir.text()
            self.refresh_config()

    def copy_path_clicked(self, checked = False):
        self.locationBar.setSelection(0, len(self.locationBar.text()))
        self.clipboard.setText(self.locationBar.text())

    def slider_value_changed(self, position):
        sound = self.player.currently_playing()
        if sound:
            sound.seek(position)
        else:
            signals_blocked = self.seek.blockSignals(True)
            self.seek.setValue(0)
            self.seek.blockSignals(signals_blocked)

if __name__ == '__main__':
    app = QtWidgets.QApplication([])
    sb = SoundBrowser(app.clipboard())
    def signal_handler(sig, frame):
        sb.clean_close()
        sys.exit(0)
    signal.signal(signal.SIGINT, signal_handler)
    sb.show()
    sys.exit(app.exec_())
